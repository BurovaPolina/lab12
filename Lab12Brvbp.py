# Вычислить сумму знакопеременного ряда |х(2n+1)|/(2n+1)!,
# где х-матрица ранга к (к и матрица задаются случайным образом), n - номер слагаемого.
# Сумма считается вычисленной, если точность вычислений будет не меньше t знаков после запятой.
# У алгоритма д.б. линейная сложность. Операция умножения –поэлементная. Знак первого слагаемого  -случайный.
# Вариант 2, ИСТбд-23

import random
import numpy as np
from decimal import Decimal, getcontext


# Функция вычисляющая сумму ряда
def sum_rows():
    # Переменные для вычислений
    n = 1
    summa = 0
    temp_matrix = x * x * x
    factorial = 6
    sign = random.choice([-1, 1])

    while True:
        # Вычисляем текущий члена ряда и складываем с предыдущими членами
        temp_row = Decimal(np.linalg.det(temp_matrix)/factorial)
        summa += sign * temp_row

        # Проверка необходимой точности вычислений
        if abs(temp_row) < 1 / (10 ** t):
            break

        # Считаем переменные для следующего члена ряда
        n += 1
        factorial *= (2 * n) * (2 * n + 1)
        sign = -sign
        temp_matrix *= x * x

    return summa


try:
    # Считываем значение точности вычислений
    t = int(input("Введите число знаков после запятой\n"))
    while t > 300 or t < 1:
        t = int(input("Введите число знаков после запятой\n"))
except ValueError:
    print("Вы ввели символ, а не число, перезапустите программу и попробуйте снова\n")

# Создаем матрицу со значениями от -1 до 1 и случайно созданным рангом k
k = random.randint(2, 10)
x = np.round(np.random.uniform(-1, 1, (k, k)), 3)

# Вывод матрицы
print(f"Сгенерированная матрица:\n{x}")

# Значение точности для Decimal
getcontext().prec = t + 100

output = sum_rows()

# ВЫводим сумму ряда
print(f"Сумма знакопеременного ряда с точностью {t} знаков после запятой: {output:.{t}f}")
